init endOfProgram and endOfLoop
out[0]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000000]endOfProgram[00000000]

if endOfLoop = zero, then endOfLoop = one
out[]a[]b[]aRev[]bRev[]endOfLoop[00000000]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]

if endOfLoop = one and a not empty, rev a.top() and endOfLoop = zero
out[]a[0]b[]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]:out[]a[]b[]aRev[0]bRev[]endOfLoop[00000000]endOfProgram[00000000]
out[]a[1]b[]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]:out[]a[]b[]aRev[1]bRev[]endOfLoop[00000000]endOfProgram[00000000]

if endOfLoop = one and b not empty, rev b.top() and endOfLoop = zero
out[]a[]b[0]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[0]endOfLoop[00000000]endOfProgram[00000000]
out[]a[]b[1]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[1]endOfLoop[00000000]endOfProgram[00000000]

if still endOfLoop = one -> a and b empty, set endOfLoop = two
out[]a[]b[]aRev[]bRev[]endOfLoop[00000001]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]

if endOfLoop = two, then endOfLoop = three
out[]a[]b[]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000011]endOfProgram[00000000]

if endOfLoop = three and aRev and bRev are both not empty, rev a.top() and b.top() and endOfLoop = two
out[]a[]b[]aRev[0]bRev[0]endOfLoop[00000011]endOfProgram[00000000]:out[]a[0]b[0]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]
out[]a[]b[]aRev[1]bRev[0]endOfLoop[00000011]endOfProgram[00000000]:out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]
out[]a[]b[]aRev[0]bRev[1]endOfLoop[00000011]endOfProgram[00000000]:out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]
out[]a[]b[]aRev[1]bRev[1]endOfLoop[00000011]endOfProgram[00000000]:out[]a[1]b[1]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]

if endOfLoop = three and aRev is emtpy but bRev not, then fill rev b.top() and fill a with zero and endOfLoop = two
out[]a[]b[]aRev[]bRev[0]endOfLoop[00000011]endOfProgram[00000000]:out[]a[0]b[0]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]
out[]a[]b[]aRev[]bRev[1]endOfLoop[00000011]endOfProgram[00000000]:out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]

if endOfLoop = three and bRev is emtpy but aRev not, then fill rev a.top() and fill b with zero and endOfLoop = two
out[]a[]b[]aRev[0]bRev[]endOfLoop[00000011]endOfProgram[00000000]:out[]a[0]b[0]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]
out[]a[]b[]aRev[1]bRev[]endOfLoop[00000011]endOfProgram[00000000]:out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000010]endOfProgram[00000000]

if still endOfLoop = three -> a and b are reversed back and filled up with zeros, set endOfLoop = four
out[]a[]b[]aRev[]bRev[]endOfLoop[00000011]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000100]endOfProgram[00000000]

if endOfLoop = four, then endOfLoop = five
out[]a[]b[]aRev[]bRev[]endOfLoop[00000100]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]
//TODO: valid until here

/*
TODO: wrong behavior for input (calculates to high) ../../demo/binary_addition.flanck -b -b 0 0000001111100111 00000101
tested inputs:
    ../../demo/binary_addition.flanck -b -b 0 0000001111100111 00000101
    ../../demo/binary_addition.flanck -b -b 0 00000101 00000101
*/
if endOfLoop = five and a and b are not inverted -> invert a and b and set endOfLoop = four
out[]a[0]b[0]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]:out[]a[]b[]aRev[0]bRev[0]endOfLoop[00000100]endOfProgram[00000000]
out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]:out[]a[]b[]aRev[1]bRev[0]endOfLoop[00000100]endOfProgram[00000000]
out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]:out[]a[]b[]aRev[0]bRev[1]endOfLoop[00000100]endOfProgram[00000000]
out[]a[1]b[1]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]:out[]a[]b[]aRev[1]bRev[1]endOfLoop[00000100]endOfProgram[00000000]

######## until here is a for value and b for carry-on ########
if still endOfLoop = five, then endOfLoop = six and b=0
out[]a[]b[]aRev[]bRev[]endOfLoop[00000101]endOfProgram[00000000]:out[]a[]b[0]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]

if endOfLoop = six, then endOfLoop = seven
out[]a[]b[]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000111]endOfProgram[00000000]

if there is no carry-on
out[]a[]b[0]aRev[0]bRev[0]endOfLoop[00000111]endOfProgram[00000000]:out[]a[0]b[0]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[0]aRev[1]bRev[0]endOfLoop[00000111]endOfProgram[00000000]:out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[0]aRev[0]bRev[1]endOfLoop[00000111]endOfProgram[00000000]:out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[0]aRev[1]bRev[1]endOfLoop[00000111]endOfProgram[00000000]:out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]

else
out[]a[]b[1]aRev[0]bRev[0]endOfLoop[00000111]endOfProgram[00000000]:out[]a[1]b[0]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[1]aRev[1]bRev[0]endOfLoop[00000111]endOfProgram[00000000]:out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[1]aRev[0]bRev[1]endOfLoop[00000111]endOfProgram[00000000]:out[]a[0]b[1]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]
out[]a[]b[1]aRev[1]bRev[1]endOfLoop[00000111]endOfProgram[00000000]:out[]a[1]b[1]aRev[]bRev[]endOfLoop[00000110]endOfProgram[00000000]

//TODO: temporary exit (set endOfProgram to true)
out[]a[]b[]aRev[]bRev[]endOfLoop[00000111]endOfProgram[00000000]:out[]a[]b[]aRev[]bRev[]endOfLoop[00000111]endOfProgram[11111111]

